# spbu-fundamentals-of-algorithms
Materials for the practicum for "Fundamentals of Algorithms" course at SpbU

## Getting started

Set up your environment

### VSCode

Go to `Run and Debug` in the left panel, create a new launch file, select `Python File` and add the following field:
```yaml
"env": {
    "PYTHONPATH": "${workspaceFolder}${pathSeparator}${env:PYTHONPATH}"
}
```

## Practicum 1

Изучение `python`, `numpy` и  `matplotlib`, необходимых для дальнейшей работы. Предполагается, что студент имеет базовые знания python.

План:
1. Выполнить `intro_to_numpy_and_matplotlib.ipynb`

## Practicum 2

Начало работы с графовыми и графовыми алгоритмами с помощью `networkx`.

План:
1. Выполнить `intro_to_networkx.ipynb`

Домашнее задание (базовый вариант):
1. Проверка на наличие циклов в ненаправленном графе: `practicum_2/homework/basic/cycles_in_undirected_graph.py`. Необходимо реализовать функцию `has_cycles`, которая принимает на вход объект графа и возвращает булевское значение, принимающее true при наличии цикла в графе. Предполагается, что, придя в узел n через ребро e в ненаправленном графе, мы можем пойти далее по любому ребру узла n, кроме e.

Домашнее задание (продвинутый вариант):
1. Проверка на наличие циклов в направленном графе: `practicum_2/homework/advanced/cycles_in_directed_graph.py`. Необходимо реализовать функцию `has_cycles`, которая принимает на вход объект графа и возвращает булевское значение, принимающее true при наличии цикла в графе. Предполагается, что, придя в узел n через ребро e в направленном графе, мы можем пойти далее по любому исходящему ребру узла n.

Дедлайн: 2024.04.06

## Practicum 3

Изучение классических графовых алгоритмов: BFS, DFS, алгоритма Прима для нахождения MST и алгоритма Дейкстры для нахождения кратчайших путей в графе. 

План:
1. Реализовать рекурсивный DFS в функции `dfs_recursive`, итерационный DFS в функции `dfs_iterative` и топологическую сортировку в функции `dfs_recursive_postorder` в файле `dfs.py`.
2. Реализовать алгоритм Прима в функции `prim_mst` в файле `mst.py`.
3. Реализовать базовый алгоритм Дейкстры в функции `dijkstra_sp` и ускорить его с помощью очереди с приоритетом в функции `dijkstra_sp_with_priority_queue` в файле `sp.py`.


Домашнее задание (базовый вариант):
1. Поиск пути в лабиринте: `practicum_3/homework/basic/bfs_maze.py`. Необходимо реализовать метод `Maze.solve`, который ищет путь в лабиринте. Лабиринт хранится в файле `practicum_3/homework/basic/maze_2.txt`, где символ `#` обозначает стену, а `O` и `X` вход и выход соответственно. Цель - построить путь от `O` к `X`. Под путем подразумевается последовательность символов `L` (шаг влево), `R` (шаг вправо), `U` (шаг вверх), `D` (шаг вниз). Например `LLDLLDDR`.
2. Проверка на корректность раскрытия скобок: `practicum_3/homework/basic/valid_parentheses.py`. Необходимо реализовать класс LIFO очереди `Stack` и затем реализовать функцию `are_parentheses_valid`, которая проверяет, содержит ли строка, переданная на вход и состоящая только из скобок `(`, `)`, `[`, `]`, `{`, `}`, корректно закрывающиеся/открывающиеся скобки. В файле `practicum_3/homework/basic/valid_parentheses_cases.yaml` содержатся корректные и некорректные примеры таких строк. 

Домашнее задание (продвинутый вариант):
1. Нахождение максимального потока в транспортной сети: `practicum_3/homework/advanced/max_flow.py`. Необходимо реализовать функцию `max_flow`, которая принимает на вход объект направленного взвешенного графа (транспортной сети) и возвращает значение максимального потока. Существует множество методов решения этой задачи, так что требуется найти наиболее быстрый метод из доступных. 

Дедлайн: 2024.04.13